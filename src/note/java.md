* 源文件名应当与public类名保持一致。一个源文件只能有一个public类，可以有多个非public类。
* static
	* static(静态)变量，static方法， static代码块
	* 对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）
	* 被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。
	* 只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。 
	* 用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量.
	* http://zhidao.baidu.com/link?url=MseSIv8EaR51WQ303hhfo1hRJ8gDDQSv_jpzwUBV2Dax_Nw242Uz8YLmTu8ZfB1MtGluSbEv96jZPQBa_OMtZq
* 类中的Final方法可以被子类继承，但是不能被子类修改。
* Jetty是一个开源的servlet容器，它为基于Java的web容器，Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供网络和web连接。
* Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
* int是一种基本数据类型，而Integer是一个类，是对int的封装,在对可能我空的数据尽量使用封装类型，因为封装类型默认为null，不会报错。
* 初始化数组三种方式：1.String[] array = new String[3];    2.int array[] = { 2, 5, -2, 6, -3, 8, 0, -7, -9, 4 };    3.Integer[] numbers = { 8, 2, 7, 1, 4, 9, 5};
* 因为List集合为列表类型，以线性方式存储对象，可以通过对象的索引操作对象。因为List接口实现了Collection接口，所以List接口拥有Collection接口提供的所有常用方法，又因为List是列表类型，所以List接口还提供了一些适合于自身的常用方法
* java实现动态长度数组一般用ArrayList或者vector。
* 成员变量在类的范围内，存在于堆内存中，会有默认的初始值，而局部变量在函数内声名，存在栈内存，声名后不赋值就会报错。一般的：定义在类里的就是成员变量，在JAVA里全局变量和成员变量是一个意思。定义在方法里或域里就叫做局部变量。[作用范围]局部变量离开了他的域{}就无效，成员变量的范围依赖他的访问修饰符
* 主函数必须使用static： static关键字，告知编译器main函数是一个静态函数。也就是说main函数中的代码是存储在静态存储区的，静态方法在内存中的位置是固定的，即当定义了类以后这段代码就已经存在了。如果main()方法没有使用static修饰符，那么编译不会出错，但是如果你试图执行该程序将会报错，提示main()方法不存在。因为包含main()的类并没有实例化（即没有这个类的对象），所以其main()方法也不会存。而使用static修饰符则表示该方法是静态的，不需要实例化即可使用。
* 基本数据类类型存的是数值本身，而引用类型变量在内存放的是数据的引用，并不是数据的本身，引用类型变量是以间接方式去获取数据。引用类型变量都属于对象类型，如：数组、类、字符串等都属于引用类型变量。所以，引用类型变量里面存放的是数据的地址
* 生存空间（栈与堆）：所有对象都存活于可垃圾回收的堆上，方法调用和局部变量在栈中。实例变量存在于对象所属的堆空间上，对象的实例变量的值是存在于该对象中。
当前执行的方法会在栈顶，如果正在执行的a方法调用了b方法。则b方法会在栈顶。


* 0初始化为bigdecimal  new BigDecimal(0)；
* 按两个字段排序，升序
    * orderBy("txdate").orderBy( "txtime") 
    * .orderBy("bussStatus asc,no desc")  升序

